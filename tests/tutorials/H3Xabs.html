<?xml version="1.0" encoding="iso-8859-15"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Tutorial: basics of BigDFT</title>
    <meta name="copyright" content="&#169; 2004-2011 CEA" />
    <link rel="author" type="text/html" href="http://www.cea.fr" hreflang="fr" lang="fr" />
    <link rel="stylesheet" type="text/css" href="../styles/original.css" />
  </head>

  <body>

    <div class="header">
      <div class="visuLogo">
        <img src="../images/logo_header.png" alt="" width="102" height="80" />
      </div>
      <!-- %%VERSION%% --><
    </div>

    <!-- %%MENU%% -->

    <div class="main"><a name="top" id="top"></a>

      <div class="floatingmenu">
        <a style="float:right;" href="H3XXXX.html">next lesson&nbsp;&gt;</a>
        <h2>Content of this lesson</h2>
        <ul>
          <li> Patching a pseudopodential with a PAW correction</li>
	      <ol> <ul>
		  <li> Generation of ptildes and psitildes to increase the psp energy range. </li>
                  <li> Fitting ptildes with complex gaussians. </li>
	      </ul></ol>
          <li> Generating an SCF potential for a small unit cell </li>	
          <li> Generating the spectra </li>
		<ol><ul>
                    <li>  Dependence on nkpts, number of Chebyshev  components, polarisation, charge ... </li>
                    <li>  Comparison to experimental data </li>
                    </ul>
                </ol>
        </ul>
        <h2  ALIGN="CENTER">Material : files are generated by <code>make exercise</code> in each subdir</h2>
        <ul style="float:left;margin-right:1em;">
	    <h3>Xabs/pawpatchgen/</h3>
           <li><a  type="text/plain"  href="Xabs/pawpatchgen/atom.dat.src">atom.dat</a></li>
           <li><a  type="text/plain"  href="Xabs/pawpatchgen/input.dat.src">input.dat</a></li>
           <li><a  type="text/plain"  href="Xabs/pawpatchgen/psppar.P.src">psppar.P</a></li>
           <li><a  type="text/plain"  href="../../pseudo/src/pawpatchfit.py">pawpatchfit.py</a></li>
        </ul>
       <ul style="float:left;margin-right:1em;">
	    <h3>Xabs/scfpotgen/</h3>
           <li><a type="text/plain"  href="Xabs/scfpotgen/posinp.xyz.src">posinp.xyz</a></li>
           <li><a type="text/plain"  href="Xabs/scfpotgen/input.dft.src">input.dft</a></li>
           <li><a type="text/plain"  href="Xabs/scfpotgen/psppar.O.src">psppar.O</a></li>
           <li><a type="text/plain"  href="Xabs/scfpotgen/psppar.Si.src">psppar.Si</a></li>
           <li><a type="text/plain"  href="Xabs/scfpotgen/psppar.P.src">psppar.P</a></li>
           <ol>   optional bigger cell<ul>
           <li><a type="text/plain"   href="Xabs/scfpotgen/posinp.xyz_72p.src">posinp.xyz_72p</a></li>
	    </ul></ol>
        </ul>
       <ul style="float:left;margin-right:1em;">
	    <h3>Xabs/spectra/</h3>
           <li><a type="text/plain" href="Xabs/spectra/input.abscalc.src">input.abscalc</a></li>
           <li><a type="text/plain" href="Xabs/spectra/input.dft.src">input.dft</a></li>
           <li><a type="text/plain" href="Xabs/spectra/input.kpt.src">input.kpt</a></li>
           <li><a type="text/plain" href="Xabs/spectra/psppar.O.src">psppar.O</a></li>
           <li><a type="text/plain" href="Xabs/spectra/psppar.Si.src">psppar.Si</a></li>
           <li><a type="text/plain" href="Xabs/spectra/posinp.xyz.src">posinp.xyz</a></li>
           <ol>   optional bigger cells<ul>
           <li><a type="text/plain"   href="Xabs/spectra/posinp_72X8p.xyz.src">posinp_72X8p.xyz</a></li>
           <li><a type="text/plain"   href="Xabs/spectra/posinp_72X27p.xyz.src">posinp_72X27p.xyz</a></li>
	    </ul></ol>
        </ul>
      </div>

    
      <h1>Xanes: calculating the spectra of Quartz</h1>

      <p>The purpose of this lesson is to get familiar with the steps required 
         to generate an x-ray absorption spectra, in particular in the Xanes region.
         These steps are three : </p> 
      <p>
	<ul>
	  <li> the first step  consists in generating a PAW patch for the pseudopotential 
               in order to extend its validity over the Xanes region.	 This region corresponds to photo-electron 
               energy from zero to few Hartree. We will do this using <emph> atom </emph>
                and <emph>pseudo</emph> programs which are distributed with the BigDft project.   
          </li>

	  <li>  The potential felt by the photoelectron can be generated by 
                a standard BigDft run. 
	        A non SCF potential can also be generated  summing atomic densities. This can be done 
                using abscalc with the  appropriate option.
	  </li><li>  We will calculate the spectra using a paw-patched pseudopotential and the local potential
                 from a BigDft calculation. Using several k-points is equivalent to calculate the spectra
                 in a larger cell whose size is a multiple of the unit cell. The number of k-points is important to get 
	         smoother spectra free from spurious band discrete sampling effects.
	         We will explore the importance of this parameters and of other parameters like the charge of the system,
	         and the light polarisation.
	  </li>
	  </ul>
	 </p> <p>
	This lesson may take XX minutes for the basic point and we give track for further testing.
	We suggest to cohordinate your runs with  your neighbours so that the test of the dependancies 
	   on different choices of certain parameters can be parallelised.
	</p>
	  <h2>  Patching a pseudopodential with a PAW correction </h2>
	  <h3> Generating the potential of the AE reference </h3>
	  <p>
	    Our goal is to calculate the Xanes spectra of Quartz at the K edge of Silicon. In order to do so we need to construct 
	  a pseudopotential, with the program pseudo,  which describes a Silicon atom with one hole in the 1s shell.
	  Our starting point will then be the pseudopotential of the Z+1 element, phosphorus, that we will patch with a PAW correction
	  that we are going to build. The Z+1 approximation consists in replacing a Z nuclear charge plus on 1s electron,
          with a Z+1 nuclear charge plus two electron. This keeps the total charge unchanged. It would  possible, 
	  with the program pseudo, to generate a new pseudopotential for Silicon with one hole, and then patch it.
	  We focus here instead on building only the PAW correction which is the original part of this method,
	  and we start therefore directly from the Z+1 pseudopotential which is already given.</p>
	  <p>
	  The calculation proceed in two steps. First we generate with the program atom  the very same all-electron (AE)
	  reference that has been used to create the pseudopotential. This first step is used to generate a radial 
	  potential that will be used, in the second step,  to generate AE eigenfunctions over a wide energy range.
	  </p><p>
	  In the second step  we create the PAW correction such that the patched pseudo potential can fit the AE energy
	  over a wider range.
	  </p><p>
	  The first step is quickly accomplished with the following command

	  <div class="exercice">
            <p><b>Exercise</b>: run <code>`../../../../pseudo/src/atom  atom.dat`</code> </p>
	  </div>
	  
	  where file <a  type="text/plain"  href="Xabs/pawpatchgen/atom.dat.src"><code>atom.dat</code></a> is the one used
	  as reference for the <a  type="text/plain"  href="Xabs/pawpatchgen/psppar.P.src"><code>psppar.P</code></a>
	  pseudopotential.


<div style="height:120px;overflow:scroll;">
<pre>	  
  P
  -20
  relativistic
       25.0      10.0 60.0       rmax,aa,bb 
       2.09d0   4.19d0		 rcov,rprb
    3    13			 number of core and valence orbitals
    3    0     2.00      0.00		   
    4    0     0.00      0.00		   
    5    0     0.00      0.00		   
    6    0     0.00      0.00		   
    3    1     3.00      0.00		   
    4    1     0.00      0.00		   
    5    1     0.00      0.00		   
    6    1     0.00      0.00		   
    3    2     0.00      0.00		   
    4    2     0.00      0.00		   
    5    2     0.00      0.00		   
    4    3     0.00      0.00		   
    5    3     0.00      0.00		   
</pre>
</div>
<p>
the format of <a  type="text/plain"  href="Xabs/pawpatchgen/atom.dat.src"><code>atom.dat</code></a> is quite simple.
On the first line we find the atomic symbol(P). Then the XC functional code ( here -20=LDA).
The fourth line contains some information on how atom must build the radial logarithmic grid.
The fifth line contains the covalent radius and the radius of the parabolic potential.
On the sixth line the first number that we find indicates how many core  bottom orbitals are fully occupied.
Here 3 means that 10 electron occupies 1s, 2s and 2p.
The second number is the number of valence orbitals that have been  calculated
by atom when   the reference for pseudo was generated. Here we are concerned only by those orbital
which have non zero occupancies. These are the one which  have influence  on  the local potential.
</p>
<p>
At the end of the run you should get in your working directory the file 
<a href="Xabs/pawpatchgen/ae.pot.conf.0.plt">   ae.pot.conf.0.plt</a>

which is the potential for configuration 0 ( pseudo can fit a pseudo potential against a set of configurations, here we have just one ).
</p>

<h3>Generation of ptildes and psitildes to increase the psp energy range. </h3>

<p>
  You are ready to generate the paw-patch :
 	  <div class="exercice">
            <p><b>Exercise</b>: run <code>`../../../../pseudo/src/pseudo  input.dat`</code> </p>
	  </div>
	  
</p>
This program, besides <i> input.dat</i>, reads several files generated by atom, and the file <i> psppar </i>
containing the initial psp parameters. In out case we dont fit the psp parameter, so <i> psppar</i>
must be coherent with the pseudopotential <i>psppar.P</i> that we want to patch.

<p>It is important to explain the option used in <a href="Xabs/pawpatchgen/input.dat">   input.dat</a> because you 
will have to fine tune them</p>
<pre>	  
-c 0 -plot -paw 0  -noflpaw 3  -nchannelspaw 2  
-pawstatom ae.pot.conf.0.plt -pawstn 1 -pawstl 0 -pawstp 1  
</pre>
<p><ul>
<li> the first two option :<code>-c0 -plot </code> tell pseudo not to fit the psp parameters, we already have that we already know :
  <a  type="text/plain"  href="Xabs/pawpatchgen/psppar.P.src"><code>psppar.P</code></a>
</li>
<li>  <b>-paw</b> 0  means : do the patch for configuration number 0    </li>
<li> <b>-noflpaw</b> 3 means that the correction are calculated of three values of angular moment : s, p and d waves.
  We suppose here that the correction for f waves would be here negligeable. </li>
<li> <b>-nchannelspaw</b> 2  means that for each angular moment two projectors are generated.
   The more projectors one has the bigger the energy range where the correction is good. </li>
<li> <b>-pawstatom</b> ae.pot.conf.0.plt  reads the local potential from file  ae.pot.conf.0.plt that we generated with atom. </li>

<p><i> the following items concern the generation of the initial photoelectron wavefuction </i></p>
<li>  <b>-pawstn</b> 1   we want to generate a wavefunction from 1s. Quantum number n is therefore 1 here </li>
<li> <b>-pawstl</b> 0   For the same reason above, we indicate here that quantum number l is 0 </li>
<li> <b>-pawstp</b> 1   This is the power of r by which we multiply the radial part of the initial wave fuction. The angular part is take care of by BigDft ( abscalc)
                        when the polarisation is known. For dipolar interaction pawstp is 1, for quadrupolar  it is 2 and so on.    </li>
</ul></p>

<p> The result of the fit can be monitored looking at the output. Here below we report the output concerning the  <code>l=0</code> space</p>


<div style="height:220px;overflow:scroll;">
<pre>	  
 ===============================================================
 ========== now CALCULATING PAWpatch correction  for l  =             0
 ===============================================================
 now calculating          100  function of the AE basis for LPaw=           0
 doing the fit 
  routine gatom_modified  ,  comparaison between  first 5 energies real and  pseudo-not_fitted 
           1  -75.952756404876709     
           2  -6.2910273671150208     
           3  0.41157764650931183       0.37085166222413934     
           4   5.9902891679064592        2.6090777062770307     
           5   14.400375561474663        6.4202517989703054     
 >>  Comparaison betwenn first 5 Egrid and   Egrid_pseudo 
  -75.952756404876709     
  -6.2910273671150208     
  0.41157764650931183       0.41157765025060822     
   5.9902891679064592        5.9902845552977215     
   14.400375561474663        14.399645486591949     
DUALITY : CONDITION NUMBER FROM DPOSVX  0.5501E+00
  first  eigenvalues 
  0.41116489582251731     
   2.9722717862947752     
   7.7169956612536588     
   13.735301520083759     
 routine pawpatch  , PROJECT  initial wf*r**pawstP on pseudos 
 From initial wave  subtract psigrid_bigger(           1 ) with coeff   0.10433231170909278     
 From initial wave  subtract psigrid_bigger(           2 ) with coeff  -3.29213674528539627E-002
 Initial Projected wf at igrid=100,500,2000
 -1.19502133768229197E-007
 -2.11513353895853788E-007
 -1.97394835887812979E-006
</pre>
</div>
<p> We can see here, below the line <code> comparaison between  first 5 energies real and  pseudo-not_fitted </code>
that, without the PAW patch, the eigenvalues  of the radial solution calculated in the AE 
potential diverges at high energies from those calculated in the pseudo potential, while in the
valence region the used  psppar.P pseudopotential fits well the AE solution within some thousandth of Hartree. <i>Nota Bene</i> that the 
radial solution is calculated from zero to the covalent radius, and this pushes the first pseudo eigenvalue
at positive energy where the difference with the AE solution is already of the order of some hundreth of Hartree.</p>
<p>
The lines below <code>   Comparaison between first 5 Egrid and   Egrid_pseudo  </code>
 show the corrected eigenvalues for a modified pseudo potential where, for each eigenvalue,
we add a short range gaussian at the nucleus with an appropriate factor such that the AE eigenvalue is recovered.
These eigensolution are our <i>psitildes</i> which  are not orthonormal but outside the core region they coincide 
with the AE solutions.</p>
<p> 
 By solving a simple linear equation we get the <i>ptildes</i> as the dual of the <i>psitildes</i> 
(line <code> DUALITY : CONDITION NUMBER FROM DPOSVX  0.5501E+00 </code>).
Once the <i>psitildes</i> and <i>ptildes</i> are know, the PAW patch is calculated as a correction
in the nchannelspaw-dimensional space spanned by <i>psitildes</i>.</p>

<p> Such correction is tested in the space spanned by the pseudo solutions ( which has a dimension of the order of 
100) and the results are plotted for comparaison.  </p>


<div class="exercice">
  <p><b>Exercise</b>: increase nchannespaw to improve the fit of the second pseudo eigenvalue </p>
</div>

<div class="exercice">
  <p><b>Exercise</b>: plot AE solutions (<i>file ae.wfs.L=0.plt </i>) and   psitildes (<i> file psitildes.L=0.plt</i>)
to verify that they really coincide outside of the core </p>
</div>

<div class="exercice">
  <p><b>For future use:</b>: -pawrcovfact0.8 or another factor can be used to change the psitildes/ptildes support </p>
</div>

 <img class="figure" src="H3Xabs-aspsitildejoin.png" alt="The psitilde joins ae wf outside of the core" />
 

<h3>Fitting ptildes with complex gaussians. </h3>

Finally the PAW patch is generated with the following command for L from 0 to 2 and using 30 complex gaussians
 
<div class="exercice">
  <p><b>Exercise</b>: run <code>`python pawpatchfit.py 0 2 30 `</code> </p>
</div>

This script create an output : <i> file pseudopaw</i> containing a description of the <i> ptildes </i> , of the initial wave function  projection in the space of pseudo-functions, for different values of  L, and the correction in the form of a numerical matrix. 
The quality of the fit can be observed plotting  these files: 
<div style="height:220px;width:250px;">
<pre>	  
fitresult_l_2_initial
fitresult_l_2_channel_1
fitresult_l_2_channel_0
fitresult_l_1_initial
fitresult_l_1_channel_1
fitresult_l_1_channel_0
fitresult_l_0_initial
fitresult_l_0_channel_1
fitresult_l_0_channel_0
</pre>
</div>

each file contains four columns : the radial position, the original numerical function, the fit to function as a sum of complex gaussian, the error.


Now the last step. Create the patched pseudopotential file ready for the spectra!!.
This is done postpending <i>  file pseudopaw</i> to <i> psppar.P</i>
<div class="exercice">
  <p><b>Exercise</b>: run <code>`cat psppar.P pseudopaw > psppar.P_1s`</code> </p>
</div>
<h2>Generating an SCF potential for a small unit cell </h2>



      <h2>Introduction: running the code</h2>
      <p>This lesson is based on this skeleton
        <a href="CH4/input.dft"><code>input.dft</code></a> file. To run electronic convergence loop,
        BigDFT requires a file named <code>input.dft</code> with all lines mandatory.</p>
      <p>Beside this input file, BigDFT requires the atomic positions
        for the studied system and the pseudo-potential files. For the
        following tutorial, a <a href="CH4/posinp.xyz">methane</a> molecule will be used. The position file
        is a simple XYZ file named <a href="CH4/posinp.xyz"><code>posinp.xyz</code></a>:</p>
      <pre>
5  angstroemd0  # a methane molecule
free
C        0           0           0
H       -0.63169789 -0.63169789 -0.63169789
H       +0.63169789 +0.63169789 -0.63169789
H       +0.63169789 -0.63169789 +0.63169789
H       -0.63169789 +0.63169789 +0.63169789</pre>
      <p>The pseudo-potential files are following the ABINIT structure
        and are of GTH or HGH types (see the <a class="external" href="http://www.abinit.org/downloads/psp-links/pseudopotentials">pseudo-potential file</a> page on the
        ABINIT website for several LDA and GGA files and the <a class="external"
                                                                href="http://cvs.berlios.de/cgi-bin/viewcvs.cgi/cp2k/potentials/Goedecker/abinit/">page
          of M. Krack</a> on the CP2K server for HGH pseudo for several
        functionals). The following files are required for this tutorial: <a
                                                                             href="CH4/psppar.C">psppar.C</a> and <a href="CH4/psppar.H">psppar.H</a>.</p>
      <p>Running BigDFT is done using the <code>bigdft</code>
        executable in a standard Unix way, the output being by default the
        standard output, it must redirected to a file or to a pipe, like with the unix command
        <code>tee</code>:</p>
      <pre>
user@garulfo:~/CH4/$ ls
bigdft    psppar.C     psppar.H     input.dft    posinp.xyz
user@garulfo:~/CH4/$ ./bigdft | tee screenOutput
...</pre>
      <p>Warning, to run properly, the input file must be named
        <code>input.dft</code>, the position file must be named
        <code>posinp.xyz</code> and the pseudo-potential files must be
        <code>psppar.XX</code> where XX is the symbol used in the position
        file.</p>
      <p>If the code has been compiled with MPI capabilities (which is
        enable by default), running BigDFT on several cores is as easy as run
        it on a serial job. There is no need to change anything in the input
        files. The following example shows how to run it on a Debian system
        with installed OpenMPI on a 4 core machine:</p>
      <pre>
user@garulfo:~/CH4/$ ls
bigdft    psppar.C     psppar.H     input.dft    posinp.xyz
user@garulfo:~/CH4/$ mpirun.openmpi -np 4 ./bigdft | tee screenOutput
...</pre>

      <h2>The wavelet basis set, a convergence study</h2>
      <p>The wavelet is a systematic basis set (as plane waves are),
        which means than one can achieve arbitrary precision by increasing
        some parameters.</p>
      <h3>The main grid parameters</h3>
      <img class="figure" src="CH4-grid.png" alt="visualisation of the real space mesh" />
      <p>The two first lines of <code>input.dft</code> are used to set
        up the basis set. In free boundary conditions, the basis set is characterised
        by a spatial expansion and a grid step, as shown in the side
        figure.</p>
      <p>There are <emph>three float values</emph> on the first line describing the
        <emph>grid steps</emph> in the three space directions (<i>i.e.</i> x, y and z). These
        values are in bohr unit and typically range from 0.2 to 0.6. The
        harder the pseudo-potential is used, the lower value should be set
        up. These values are called <code>hgrid</code>.</p>
      <p>The second line contains two float values that are two
        multiplying factors. They multiply quantities that are chemical
        species dependant. The first factor is the most important since it
        describes <emph>the spatial expansion</emph> of the basis set (in
        yellow on the figure beside). Indeed the basis set
        is defined as a set of real space points with non-zero values. These points are
        on a global regular mesh and located inside spheres centered on
        atoms. The first multiplying factor is called <code>crmult</code> for
        Coarse grid Radius MULTiplier. Increasing it means that further
        spatial expansion is possible for the wavefunctions. Typical values
        are 5 to 7.</p>

      <div class="exercice">
        <p><b>Exercise</b>: run BigDFT for the following
          values of <code>hgrid</code> and <code>crmult</code> and plot the
          total energy convergence versus <code>hgrid</code>. The final total energy
          can be retrieved at the end of the screen output, or using this command
          <code>`grep FINAL screenOutput`</code>, the value is in Hartree. A
          comprehensive explanation of the screen output
          will be given later in this tutorial.</p>
        <pre>
hgrid = 0.55bohr / crmult = 3.5
hgrid = 0.50bohr / crmult = 4.0
hgrid = 0.45bohr / crmult = 4.5
hgrid = 0.40bohr / crmult = 5.0
hgrid = 0.35bohr / crmult = 5.5
hgrid = 0.30bohr / crmult = 6.0

hgrid = 0.20bohr / crmult = 7.0</pre>
        <img class="figureR" src="CH4-cv.png" alt="Convergence rate" />
        <p class="answer">This precision plot shows the systematicity of
          the wavelet basis set: by improving the basis set, we improve the
          value of the total energy.</p>
        <pre>
hgrid = 0.55bohr / crmult = 3.5  -->  -8.025214Ht
hgrid = 0.50bohr / crmult = 4.0  -->  -8.031315Ht
hgrid = 0.45bohr / crmult = 4.5  -->  -8.032501Ht
hgrid = 0.40bohr / crmult = 5.0  -->  -8.033107Ht
hgrid = 0.35bohr / crmult = 5.5  -->  -8.033239Ht
hgrid = 0.30bohr / crmult = 6.0  -->  -8.033300Ht

hgrid = 0.20bohr / crmult = 7.0  -->  -8.033319Ht</pre>
      </div>

      <p>To go further, one can vary <code>hgrid</code> and
        <code>crmult</code> independantly. This is shown of the previous
        figure with the grey line. The shape of the convergence curve shows that both these
        parameters should be increased in accordance to obtained the better
        efficiency. Indeed, there are two kind of errors arising from the
        basis set. The first one is due to the fact the basis set can't
        account for quickly varying wavefunctions (value of <code>hgrid</code> should
        be decreased). The second error is the fact that the wavefunctions are
        constrained to stay inside the defined basis set (output values are
        zero). In the last case <code>crmult</code> should be raised.</p>

      <h3>Fine tuning of the basis set</h3>
      <p>The multi-scale property of the wavelets is used in BigDFT and
        a two level grid is used for the calculation. We've seen previously
        the coarse grid definition using the the multiplying factor
        <code>crmult</code>. The second multiplying value on this line of the
        input file is used for the fine grid and is called
        <code>frmult</code>. As <code>crmult</code> it defines a factor for
        the radii used to define the fine grid region where the grid step is
        indeed half the one of the coarse grid. It allows to define region
        near the atoms where the wavefunctions are allowed to vary more
        quickly. Typical values for this factor are 8 to 10. It's worth to
        note that even if the value of the multiplier is greater than
        <code>crmult</code> it defines a smaller region due to the fact that
        the physical quantities that are multiplied are greatly different.</p>

      <p>The physical quantities used by <code>crmult</code> and
        <code>frmult</code> can be changed in the pseudo-potential by adding
        an additional line with two values in bohr. The two values that the
        code are using (either computed or read from the pseudo-potential
        files) are output in the following way in the screen output:</p>
      <pre>
------------------------------------------------------------------ System Properties
Atom    N.Electr.  PSP Code  Radii: Coarse     Fine  CoarsePSP    Calculated   File
Si          4      10            1.80603  0.43563  0.93364         X
 H          1      10            1.46342  0.20000  0.00000         X</pre>

      <h2>Analysing the output</h2>

      <p>The output of BigDFT is divided into four
        parts:</p>
      <ul>
        <li>Input values are printed out, including a summary of the
          different input files (DFT calculation parameters, atom positions,
          pseudo-potential values...).</li>
        <li>Input wavefunction creation, usually called "input guess".</li>
        <li>The SCF loop itself.</li>
        <li>The post SCF calculations including the forces calculation and
          other possible treatment like a finite size effect estimation or a
          empty state evaluation.</li>
      </ul>

      <h3>The system parameters output</h3>
      <p>All the read values from the different input files are printed
        out at the program startup. Some additional values are provided there
        also, like the memory consumption. Values are given for one process,
        which corresponds to one core in an MPI environment.</p>
      <pre>
Estimation performed for 1 processors.
Memory occupation for principal arrays:
           Poisson Solver Kernel (K):    11 MB     9 KB
          Poisson Solver Density (D):    10 MB   736 KB
 Single Wavefunction for one orbital:     0 MB   412 KB
All Wavefunctions for each processor:     3 MB   217 KB
   Wavefunctions + DIIS per proc (W):    22 MB   493 KB
 Nonlocal Pseudopotential Arrays (P):     1 MB   256 KB
Arrays of full uncompressed grid (U):    10 MB   445 KB
Estimation of Memory requirements for principal code sections:
Kernel calculation | Density Construction | Poisson Solver | Hamiltonian application
     ~11*K         |     ~W+(~3)*U+P      |   ~8*D+K+W+P   |       ~W+(~3)*U+P
     121MB         |        59MB          |      120MB     |            63MB
The overall memory requirement needed for this calculation is thus: 121 MB</pre>
      <p>In this example, the memory requirement is given for one
        process run and the peak of memory will be in the initialisation during
        the Poisson solver kernel creation, while the SCF loop will reach
        120MB during the Poisson solver calculation. For bigger systems, with
        more orbitals, the peak of memory is usually reached during the
        Hamiltonian application.</p>

      <div class="exercice">
        <p><b>Exercise</b>: run a small utility program provided with
          BigDFT called <code>memguess</code> to estimate the memory requirement
          of a run before submitting it to the queue system of a
          super-computer. It reads the same input file than the
          <code>bigdft</code> executable, and is thus convenient to validate inputs.</p>
        <p>The executable take one mandatory argument that is the number
          of cores to run BigDFT on. Try several values from 1 to 6 and discuss
          the memory distribution.</p>
        <pre>
user@garulfo:~/CH4/$ ls
memguess    psppar.C     psppar.H     input.dft    posinp.xyz
user@garulfo:~/CH4/$ ./memguess 2
...</pre>
        <p class="answer">BigDFT distributes the orbitals over the
          available processes (the value W does not decrease anymore after 4
          processes since there are only 4 bands in our example). This means that running a parallel job with more
          processors than orbitals will result in a bad speedup. The only useful
          case for this situation is to accelerate the Poisson solver part since
          the data are then distributed by slices of data along z axis, but this
          case is hardly necessary since the part of Poisson solver in total time in BigDFT is small.</p>
      </div>

      <h3>The input guess</h3>
      <p>The initial wavefunctions in BigDFT are calculated using the
        atomic orbitals for all the electrons of the layer s, p,
        d... described in the pseudo-potential files.</p>
      <pre>
------------------------------------------------------- Input Wavefunctions Creation
Generating 8 Atomic Input Orbitals
Calculating AIO wavefunctions:
Generation of input wavefunction data for atom     Si:
Elec. Configuration: s 2.00 , p 2/3 2/3 2/3 , ... done.
Generation of input wavefunction data for atom      H:
Elec. Configuration: s 1.00 , ... done.</pre>
      <p>The corresponding hamiltonian is then diagonalised and the
        n_band lower eigenfunctions are used to start the SCF loop. BigDFT outputs the
        eigenvalues, in the following example, 8 electrons were used in the
        input guess and the resulting first fourth eigenfunctions will be used
        for a four band calculation.</p>
      <pre>
evale(1)= -4.98848660956292E-01
evale(2)= -2.96722074331402E-01 <-
evale(3)= -2.96722074331392E-01 <-
evale(4)= -2.96709661080897E-01 <- Last eigenvalue for input wavefunctions
evale(5)=  2.11809378854898E-01 <- First virtual eigenvalue
evale(6)=  2.11809378854908E-01 <-
evale(7)=  2.11840178912206E-01 <-
evale(8)=  2.75381770456322E-01</pre>

      <h3>The SCF loop</h3>
      <p>The SCF loop follows a direct minimisation scheme and is made of the following steps:</p>
      <ul>
        <li>Calculate the charge density from the previous wavefunctions.</li>
        <li>Apply the Poisson solver to obtain the Hartree potential from the
          charges and calculate the exchange-correlation energy and the energy
          of the XC potential thanks to the chosen functional.</li>
        <li>Apply the resulting hamiltonian on the current wavefunctions.</li>
        <li>Precondition the result and apply a steepest descent or a DIIS
          history method (depending on the eighth line of
          <code>input.dft</code> file, the second value there is the DIIS
          history length, which is usually 5 or 6 and should be put to 0 for SD
          minimisation).</li>
        <li>Orthogonalise the new wavefunctions.</li>
      </ul>
      <p>Then, BigDFT outputs a summary of the parts of the energy:</p>
      <pre>
ekin_sum,epot_sum,eproj_sum  3.64259022248E+00 -7.36428408477E+00  8.12352945587E-01
   ehart,   eexcu,    vexcu  1.10861548797E+01 -2.52372174335E+00 -3.25827241726E+00</pre>
      <p>Finally the total energy and the square norm of the residue
        (gnrm) are printed out. The gnrm value is the stopping criterion. It is
        chosen at the sixth line of the <code>input.dft</code> file. A common
        value is 1e-4 and good value can reach 1e-5 (for more precise forces).</p>
      <pre>
iter,total energy,gnrm     2  -6.24926323942341266E+00  5.87E-02</pre>

      <div class="exercice">
        <p><b>Exercise</b>: run <code>`grep "total energy" screenOutput`</code> and
          look at the convergence rate for our methane molecule.</p>
        <p class="answer">The minimisation scheme coupled with DIIS (and
          thanks to the good preconditioner) is a very efficient way to obtain
          convergence for systems with a gap, even with a very small one. Usual run
          should reach the 1e-4 stop criterion within 15 to 25
          iterations. Otherwise, there is an issue with the system, there is no
          gap, or the input guess is wrong due to degeneracy at Fermi level,
          specific spin arrangements...</p>
      </div>

      <h3>The post-SCF treatments</h3>
      <p>At the end of the SCF loop, a diagonalisation of the current
        hamiltonian is done to obtain Kohn-Sham eigenfunctions. The
        corresponding eigenvalues are also given.</p>
      <p>The forces are then calculated.</p>
      <p>Some other post-SCF may be done depending on the
        <code>input.dft</code> file:</p>
      <ul>
        <li>One can run an estimation of finite-size effects. This is
          explained in the manual.</li>
        <li>One can run a Davidson treatment on the current hamiltonian to
          obtain the energies (and virtual wavefunctions) of the first
          unoccupied levels. This is the purpose of the next part of this tutorial.</li>
      </ul>

      <div class="exercice">
        <p><b>Exercise</b>: Before going further, review the
          <code>input.dft</code> file to identify the meaning of the different
          lines as explained previously.</p>
        <p class="answer">1st line, "0.450 0.450 0.450" hx, hy, hz are the
          grid spacing in the three directions.</p>
        <p class="answer">2nd line, "5.0  9.0" crmult, frmult define the
          basis set real space expansion.</p>
        <p class="answer">3rd line, "1" defines the exchange correlation
          functional, following the ABINIT numbering convention.</p>
        <p class="answer">6th line, "1.e-04" is the stop criterion.</p>
        <p class="answer">7th line, "50 10" the first value is the maximum
          number of SCF iteration and the second is the maximum number of
          restart after a fresh diagonalisation if convergence is not reached.</p>
        <p class="answer">8th line, "6 6" the second value is the length
          of the DIIS history and should be put to 0 to use SD instead.</p>
      </div>

      <div class="exercice">
        <p><b>Exercise</b>: run <code>memguess</code> when varying the
          DIIS history length and discuss the memory consumption.</p>
        <p class="answer">Reducing the DIIS history is a good way to
          reduce the memory consumption when one cannot increase the
          number of processes. Of course this implies more iterations in SCF loops.</p>
      </div>

      <!--    <h2>HOMO / LUMO gap and visualisation of orbitals</h2>
              <p>BigDFT provides a Davidson method to obtain the HOMO / LUMO gap
                of molecules.</p> -->

      <h2>Adding a charge</h2>
      <p>BigDFT can treat charged system without the requirement to add
        a compensating background like in plane waves.</p>
      <p>The additional charge to add to the system is set in the
        <code>input.dft</code> file at the fourth line. In the following
        example an electron has been added (-1):</p>
      <pre>
-1 0.000 ncharge efield</pre>

      <div class="exercice">
        <p><b>Exercise</b>: remove the last hydrogen atom in the previous
          methane example and modify <code>input.dft</code> to add an
          electron. Then run BigDFT for an electronic convergence.</p>
        <p class="answer">One can notice that the total charge in the
          system is indeed -8 thanks to the additional charge. The convergence
          rate is still good for this CH<sub>3</sub><sup>-</sup> radical since
          it is a closed shell system.</p>
      </div>

      <h2>Running a geometry optimisation</h2>
      <p>In the previous charged example the geometry of the radical is
        kept the same than for the methane molecule, while it is likely to
        change. One can thus optimize the geometry with BigDFT.</p>
      <p>To run geometry calculations (molecular dynamics, structure
        optimisations...) one should add another input file called <a
                                                                      href="CH3-/input.geopt"><code>input.geopt</code></a>. The first line
        of this file contains the method to use. Here, we look for a local
        minimum so we can use the keyword <code>LBFGS</code>. The third line of
        this file contains the stopping criteria. There are two stopping
        criteria: the first being ... and the second is the maximum on
        forces. For isolated systems, the first criterion is well adapted
        while the second is good for periodic boundary conditions.</p>

      <div class="exercice">
        <p><b>Exercise</b>: take the CH<sub>3</sub><sup>-</sup> radical
          <code>posinp.xyz</code> file, add the <code>input.geopt</code> and run
          a geometry optimisation.</p>
        <p class="answer">The evolution of the forces during relaxation
          can be easily obtained running `grep FORCES screenOutput`. At each
          iteration, BigDFT outputs a file <code>posoutXXX.xyz</code> with the
          geometry of the iteration XXX.</p>
      </div>
    </div>

    <div class="footer">Author (Damien D Caliste A cea D fr)
      |
      <a href="http://validator.w3.org/check/referer" title="Check HTML compliance with W3C norms">XHTML1.0</a> - 
      <a href="http://jigsaw.w3.org/css-validator/check/referer" title="Check CSS compliance with W3C norms">CSS2</a>
      |
      <!-- hhmts start -->
      Last modified: Mon May 30 11:13:37 CEST 2011
      <!-- hhmts end -->
    </div>

  </body>
</html>
