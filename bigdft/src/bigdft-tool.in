#!/usr/bin/env python
# -*- coding: us-ascii -*-

# @file
# This script is used to wrap the @ref memguess executable  but also to perform
# some useful manipulations of atomic position files.
# @author
# Copyright (C) 2012-2016 BigDFT group
# This file is distributed under the terms of the
# GNU General Public License, see ~/COPYING file
# or http://www.gnu.org/copyleft/gpl.txt .
# For the list of contributors, see ~/AUTHORS


import sys
import os.path
import os
from optparse import OptionParser, OptionGroup

#Hack for non-system installations.
PyYAML_path = "@AX_PYYAML_PATH@"
if not PyYAML_path == "system":
  sys.path.insert(0, PyYAML_path)

# This list can be converted in a dictionary with also the extra arguments
actions = ["memory-estimation", "rotate", "convert-field",
           "export-wf", "export-grid", "atomic-wf", "GPU-test", 
           "convert-positions", "manual", "wizard", "transform-coordinates",
           "pdos", "kernel-analysis", "extract-submatrix", "solve-eigensystem", 
           "analyze-coeffs", "peel-matrix", "multiply-matrices", "matrixpower", 
	   "plot-wavefunction", "suggest-cutoff", "charge-analysis", "dos",
           "export-proj", "fit-proj"]

# Processed lines
abs_srcdir = "@abs_srcdir@"
inputvarfile = abs_srcdir + '/input_variables_definition.yaml'
abs_top_builddir = "@abs_top_builddir@"
#Working with PSolver
#abs_top_srcdir = "@abs_top_srcdir@"
#inputvarfile = abs_top_srcdir + '/PSolver/src/PS_input_variables_definition.yaml'
bindir = "@prefix@"
# Other part of the script needs no processing.


def toHelp(list):
    ret = ""
    for ele in list[:-1]:
        ret += ele + ", "
    ret += "or " + list[-1]
    return ret


def parse():
    "Parse the command line"
    parser = OptionParser("usage: bigdft-tool -a ACTION")
    parser.add_option("-a", "--action", default=actions[0],
                      help="perform one of the action: %s " % toHelp(actions) +
                      "[default: %default]. "
                      "Possible options for each action are described below.")
    parser.add_option("--name", type="string", default="", metavar="NAME",
                      help="read input files using NAME as radical [default: not specified]")
    parser.add_option("-l", "--log-to-disk", action="store_true",
                      help="write output to disk [default: False]")

    # The memory estimation.
    group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[0],
                        "Performing memory estimation for a run of BigDFT.")
    group.add_option("-n", "--n-proc", type="int", default=1, metavar="N",
                     help="provide the number of processors that should be"
                     " tested [default: %default]")
    parser.add_option_group(group)

    # The rotation.
    group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[1],
                        "Rotate the input file to use the smallest mesh possible"
                        " using files following NAME scheme.")
    parser.add_option_group(group)

    # The field converter.
    group = OptionGroup(parser, "bigdft-tool -a %s FROM TO" % actions[2],
                        "Convert the given scalar field to another format, files"
                        " FROM and TO are of the form <file.{etsf,cube}>.")
    parser.add_option_group(group)

    # Wavefunction exportation.
    group = OptionGroup(parser, "bigdft-tool -a %s FILE" % actions[3],
                        "Export the compressed wavefunction from FILE to a scalar-field"
                        " representation in Cube format. If FILE is in ETSF format,"
                        " one should provide the characteristic of the orbital to export"
                        " with the following options.")
    group.add_option("--i-band", type="int", default=1, metavar="BAND",
                     help="choose the orbital to export [default: %default]")
    group.add_option("--i-kpt", type="int", default=1, metavar="KPT",
                     help="choose the k-point to export [default: %default]")
    group.add_option("--i-spin", type="int", default=1, metavar="SPIN",
                     help="choose the spin orientation to export [default: %default]")
    group.add_option("--i-complex", type="int", default=1, metavar="CPLX",
                     help="choose the real or imaginary part to export [default: %default]")
    parser.add_option_group(group)

    # Projector tools
    group = OptionGroup(parser, "bigdft-tool -a %s FILE [options]" % actions[22],
                        "Export the compress projector from FILE to a scalar-field."
                        " representation in Cube format.")
    parser.add_option_group(group)

    group = OptionGroup(parser, "bigdft-tool -a %s FILE [options]" % actions[23],
                        "Fit in gaussians the radial part of projectors.")
    group.add_option("--n-funcs", type="int", default=10, metavar="NGAUSS",
                     help="number of independant gaussians [default: %default]")
    parser.add_option_group(group)

    # Grid exportation
    group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[4],
                        "Export in XYZ format the positions of all grid points.")
    parser.add_option_group(group)

    # GAtom
    group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[5],
                        "Calculates the atomic wavefunctions of the first"
                        " atom in the gatom basis.")
    group.add_option("--n-gaussians", type="int", default=31, metavar="NUM",
                     help="number of gaussians used in gatom calculation"
                     " in atomic-wf action [default: %default]")
    parser.add_option_group(group)

    # Test GPU speed
    group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[6],
                        "Test the speed of 3D operators with GPU.")
    group.add_option("--n-repeats", type="int", default=5, metavar="NUM",
                     help="number of repeated calculations in"
                     " GPU-test action [default: %default]")
    group.add_option("--n-orbs", type="int", default=0, metavar="NUM",
                     help="limit the number of computed orbitals in"
                     " GPU-test action [default: %default]")
    parser.add_option_group(group)

    # Convert positions
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[7],
                        "Convert the <input> position file to the <output> format"
                        " the allowed formats are xyz, ascii and yaml")
    parser.add_option_group(group)

    # Manual
    group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[8],
                        "Input file manual: helps in identifying the input variables which are interesting")
    group.add_option("--profile", type="str", default="single-point", metavar="NAME",
                     help="Write an input file corresponding to profile named NAME")
    group.add_option("--find-key", type="str", default=None, metavar="NAME",
                     help="Find the keys which are typographically similar to NAME")
    parser.add_option_group(group)

    # Wizard
    group = OptionGroup(parser, "bigdft-tool -a %s" % actions[9],
                        "BigDFT wizard: Browse over all input variables to help the user")
    parser.add_option_group(group)

    # Conversion from cartesian to internal or vice versa, plus file format conversion
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[10],
                        "conversion from cartesian to internal coordinates")
    #group.add_option("--direction", type="str", metavar="NAME",
    #                 help="indicates the direction of the coordinate transform (carint = cartesian to internal, intcar = internal to cartesian")
    group.add_option("--infile", type="str", default="posinp.xyz", metavar="NAME",
                     help="input file to read the coordinates from [default: %default]")
    group.add_option("--outfile", type="str", default="posout.xyz", metavar="NAME",
                     help="output file to write the coordinates to [default: %default]")
    parser.add_option_group(group)

    # (partial) density of states for the linear scaling version
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[11],
                        "(partial) density of states for the linear scaling version")
    group.add_option("--coeff_file", type="str", default="coeff.bin", metavar="COEFFNAME",
             		 help="input file with the coefficients [default: %default]")
    group.add_option("--nbasis", type="int", default=1, metavar="NUM",
                     help="number of support functions [default: %default]")
    group.add_option("--norb", type="int", default=1, metavar="NUM",
                     help="number of orbitals [default: %default]")
    #group.add_option("--interval", type="float", default=0.01, metavar="NUM",
    #                 help="energy interval [default: %default]")
    group.add_option("--pdos_file", type="string", default=1, metavar="PDOSFILE",
                     help="TMBs to be considered for PDOS [default: %default]")

    # calculate a full kernel from the coeffs and compare it to the sparse one
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[12],
                        "calculate a dense kernel from the coefficients and compare it to the sparse one")
    group.add_option("--kernel_file", type="str", default="kernel.bin", metavar="KERNELNAME",
             		 help="input file with the coefficients [default: %default]")
    group.add_option("--nat", type="int", default=1, metavar="NUM",
                     help="number of atoms [default: %default]")

    # extract a submatrix
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[13],
                        "extract a submatrix")
    group.add_option("--matrix_file", type="str", default="matrix.bin", metavar="MATRIXNAME",
             		 help="input file with the matrix[default: %default]")
    group.add_option("--nsubmatrices", type="int", default=1, metavar="NUM",
                     help="number of submatrices [default: %default]")

    # solve the eigensystem to get the coefficients
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[14],
                        "solve eigensystem")
    group.add_option("--hamiltonian_file", type="str", default="ham.bin", metavar="MATRIXNAME",
             		 help="input file with the hamiltonian[default: %default]")
    group.add_option("--overlap_file", type="str", default="ham.bin", metavar="MATRIXNAME",
             		 help="input file with the overlap matrix[default: %default]")

    # solve the eigensystem to get the coefficients
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[15],
                        "analyze the coeffs")
    group.add_option("--ncategories", type="int", default="1", metavar="NUM",
             		 help="number of categories[default: %default]")

    # peel a matrix
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[16],
                        "peel a matrix by stripping off elements which are outside of a cutoffs")
    group.add_option("--cutoff", type="float", default="1", metavar="NUM",
             		 help="cutoff radius[default: %default]")

    # multiply two matrices
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[17],
                        "multiply two matrices")
    group.add_option("--amatrix_file", type="str", default="amatrix.bin", metavar="MATRIXNAME",
             		 help="matrix A[default: %default]")
    group.add_option("--bmatrix_file", type="str", default="bmatrix.bin", metavar="MATRIXNAME",
             		 help="matrix B[default: %default]")
    group.add_option("--cmatrix_file", type="str", default="cmatrix.bin", metavar="MATRIXNAME",
             		 help="matrix C[default: %default]")

    # apply an operator to a matrix (M^x)
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[18],
                        "calculate matrix**power")
    group.add_option("--inmatrix_file", type="str", default="inmatrix.bin", metavar="MATRIXNAME",
             		 help="matrix A[default: %default]")
    group.add_option("--outmatrix_file", type="str", default="outmatrix.bin", metavar="MATRIXNAME",
             		 help="matrix B[default: %default]")
    group.add_option("--power", type="float", default="1.0", metavar="NUM",)

    # plot wavefunction, to be improved
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[19],
                        "plot wavefunction")

    # suggest cutoff radii for the linear scaling version
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[20],
                        "suggest cutoff radii")
    group.add_option("--posinp_file", type="str", default="posinp.xyz", metavar="NAME",
             		 help="posinp file[default: %default]")

    # suggest cutoff radii for the linear scaling version
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[21],
                        "Loewdin charge analysis")
	# MPI...
    group.add_option("--mpirun", type="str", default="mpirun -n 1", metavar="MPI",
             		 help="MPI wrapper to run in parallel [default: %default]")
	# Charge analysis method
    group.add_option("--method", type="str", default="loewdin", metavar="METHOD",
             		 help="method for the charge analysis [default: %default]")

    # density of states for the linear scaling version
    group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[22],
                        "density of states for the linear scaling version")
    group.add_option("--sigma", type="float", default=0.01, metavar="NUM",
             		 help="spread of the peaks [default: %default]")
    group.add_option("--npts", type="int", default=1400, metavar="NUM",
                     help="number of points for the discretization [default: %default]")

    return parser


def closest_keys(allkeys, searchfor):
    "Find the closest keys"
    from difflib import SequenceMatcher
    matching_keys = []
    # weight the keys which matches the most
    for k in allkeys:
        s = SequenceMatcher(lambda x: x == " ", searchfor, k)
        matching_keys.append([k, s.ratio()])
        matching_keys.sort(key=lambda x: x[1])
        matching_keys.reverse()
    return matching_keys


def find_files(parameters, key):
    "Find the fields which have this key"
    files = []
    for f in parameters:
        if key in parameters[f].keys():
            files.append(f)
    return files


# Use curses module (menu in terminal)
from time import sleep
import curses


MENU = "menu"
COMMAND = "command"
EXITMENU = "exitmenu"
INPUT = "input"
PROMPT = "prompt"


def runmenu(h, n, screen, menu, parent):
    "This function displays the appropriate menu and returns the option selected"
    optioncount = len(menu['options'])  # how many options in this menu
    # work out what text to display as the last menu option
    if parent is None:
        lastoption = "Exit (press 'Q' key)"
    else:
        lastoption = "Return to %s menu (press 'Q' key)" % parent['title']
    lastoption = "%d - %s" % (optioncount + 1, lastoption)
    #Size of the window
    screenH,screenW = screen.getmaxyx()

    #Build the title
    screen.border(0)
    # Title for this menu
    if menu['type'] == 'input':
        screen.addstr(2, 2, 'Toto', curses.A_BOLD)
    else:
        screen.addstr(2, 2, menu['title'], curses.A_BOLD)
    iy = 4
    if menu.has_key('DESCRIPTION'):
        for chain in menu['DESCRIPTION'].split('\n'):
            screen.addstr(iy, 2, chain, curses.A_BOLD)
            iy += 1
        iy += 1
    # Subtitle for this menu
    screen.addstr(iy, 2, menu['subtitle'], curses.A_BOLD)
    #Build a pad
    Wpad = screenW-2
    Hpad_screen = screenH-6
    menu_pad = curses.newpad(optioncount+1,max(Wpad,len(lastoption)+4))
    # Display all the menu items, showing the 'line' item highlighted
    for index in range(optioncount):
        menu_pad.addstr(index, 0, "%d - %s" % (index + 1, menu['options'][index]['title']), n)
    # Now display Exit/Return at bottom of menu
    menu_pad.addstr(optioncount, 0, lastoption, n)
    #Important to display menu_pad before the first key-press!!
    screen.refresh()

    # line is the zero-based index of the hightlighted menu option. Every time
    # runmenu is called, line returns to 0, when runmenu ends line
    # is returned and tells the program what opt$
    line = 0
    # control for while loop, let's you scroll through options until return
    # key is pressed then returns line to program
    x = None
    pos = 0
    # Loop until return key is pressed, or esc key
    while x != ord('\n') and x != ord('q') and x != ord('Q'):
        menu_pad.chgat(line,0,Wpad,h)
        menu_pad.refresh(pos,0,4,2,screenH-2,Wpad)
        x = screen.getch()  # Gets user input
        menu_pad.chgat(line,0,Wpad,n)
        # What is user input?
        # this line can be used only if optioncount is lower than 8
        if x >= ord('1') and x <= ord(str(min(optioncount + 1, 9))):
            # convert keypress back to a number, then subtract 1 to get index
            line = x - ord('0') - 1
        elif x == curses.KEY_DOWN:  # down arrow
            line += 1
            if line > optioncount:
                line = 0
                pos = 0
            if line-pos > Hpad_screen: pos += 1
        elif x == curses.KEY_UP:  # up arrow
            line += -1
            if line < 0:
                line = optioncount
                pos = line - Hpad_screen
            if line-pos < 0: pos -= 1
        elif x == ord('q') or x == ord('Q'):  # esc key
            line = optioncount
    # return index of the selected item
    return line


def dump_info(h, n, screen, menu, parent):
    """Dump some information in the screen and come back to previous menu when done.
    menu must contains 'title', 'subtitle' and 'DESCRIPTION'. """
    pos = 0
    oldpos = None
    x = None
    lastoption = "Press Enter or 'Q' key to come back to %s menu" % parent['title']
    screenH,screenW = screen.getmaxyx()
    #Build the height of the pad
    padH = 2*len(menu) + len(menu['DESCRIPTION'].split('\n'))
    for v in menu.values():
        padH += len(yaml.dump(v,default_flow_style=False).split('\n')) + 2
    dump_pad = curses.newpad(padH,screenW-2)
    m = menu.items()
    m.sort(menu_cmp, key= lambda s: s[0])
    # Title for this menu
    dump_pad.addstr(1, 2, m[0][1], curses.A_STANDOUT)
    # Subtitle for this menu
    dump_pad.addstr(3, 2, m[1][1], curses.A_BOLD)
    # Display all the menu items, showing the 'pos' item highlighted
    iy = 3
    for chain in m[2][1].split('\n'):
        iy += 1
        dump_pad.addstr(iy, 4, "%s" % chain, n)
    #Now all the other keys
    for (k,v) in m[3:]:
        if k == 'type' or k == 'COMMENT':
            pass
        else:
            iy += 1
            dump_pad.addstr(iy, 2, k, curses.A_BOLD)
            if isinstance(v,dict):
                text = yaml.dump(v,default_flow_style=False)
            else:
                text = str(v)
            for chain in text.split('\n'):
                iy += 1
                dump_pad.addstr(iy, 4, "%s" % chain, n)
            iy += 1
    # Now display Exit/Return at bottom of menu
    iy += 1
    dump_pad.addstr(iy, 2, " %s" % lastoption, h)
    #Display the information
    screen.border(0)
    screen.refresh()
    # Loop until return key is pressed
    pos = 0
    while x != ord('\n') and x != ord('q') and x != ord('Q'):
        dump_pad.refresh(pos,0,1,1,screenH-2,screenW-2)
        x = screen.getch()  # Gets user input
        if x == curses.KEY_DOWN:
            pos += 1
            pos = min(pos, iy - (screenH-4))
        elif x == curses.KEY_UP:
            pos -= 1
            pos = max(pos,0)
    # return index of the selected item
    return 0


def input_info(h, n, screen, menu, parent):
    """Search a key and dump info about it."""
    pos = 0
    oldpos = None
    x = None
    screenH,screenW = screen.getmaxyx()
    # Title for this menu
    screen.addstr(1, 2, 'Search a key', curses.A_STANDOUT)
    # Subtitle for this menu
    screen.addstr(3, 2, 'Please type a key:', curses.A_BOLD)
    #Display the information
    screen.border(0)
    screen.refresh()
    # Loop until return key is pressed
    key = ''
    posmin = 1 + len('Please type a key:') + 1
    blank = ' '*(screenW-posmin)
    pos = posmin
    while x != ord('\n'):
        pos = max(posmin,pos)
        if x == None:
            pass
        elif x >= ord('a') and x <= ord('z'):
            key += chr(x)
            pos += 1
        elif x == curses.KEY_BACKSPACE:
            key = key[:-1]
            pos -= 1
        screen.addstr(3,posmin,key,curses.A_NORMAL)
        screen.refresh()
        x = screen.getch()  # Gets user input
        #Remove the key and generate it (no pb with cursor)
        screen.addstr(3,posmin,blank,curses.A_NORMAL)
    #We have a key
    searchfor = key
    allkeys = []
    for f in files:
        allkeys += params[f].keys()
    matching_keys = closest_keys(allkeys, searchfor)
    #print 'matching', searchfor, 'in:', matching_keys
    #print "keys wich match the most with '%s'" % searchfor
    foundkeys = []
    text = '\n'
    for (i, ratio) in matching_keys:
        if ratio > 0.6 and i not in foundkeys:
            for f in find_files(params, i):
                text += '%s (Field: %s, similarity=%4.2f)\n' % (i,f,ratio) 
                text += yaml.dump(params[f][i], default_flow_style=False, explicit_start=False)
                foundkeys.append(i)
                text += '\n'
    #curses.endwin()
    #for chain in text.split('\n'):
    #    print text
    #sys.exit(0)
    #Build the pad
    padH = 3 + max(len(text.split('\n')),200)
    dump_pad = curses.newpad(padH,screenW-2)
    # Title for this menu
    dump_pad.addstr(1, 2, "Keys which match the most with '%s'" % searchfor, curses.A_STANDOUT)
    # Display all the menu items, showing the 'pos' item highlighted
    iy = 1
    if text == '':
        iy += 1
        dump_pad.addstr(iy, 4, "No key found", curses.A_NORMAL)
    else:   
        for chain in text.split('\n'):
            iy += 1
            if 'Field:' in chain:
                dump_pad.addstr(iy, 4, "%s" % chain, curses.A_BOLD)
            else:
                dump_pad.addstr(iy, 4, "%s" % chain, curses.A_NORMAL)
    lastoption = "Press Enter or 'Q' key to come back to '%s menu'" % parent['title']
    dump_pad.addstr(iy+1, 2, " %s" % lastoption, curses.A_STANDOUT)
    #Display the information
    screen.border(0)
    screen.refresh()
    # Loop until return key is pressed
    pos = 0
    x = None
    while x != ord('\n') and x != ord('q') and x != ord('Q'):
        dump_pad.refresh(pos,0,1,1,screenH-2,screenW-2)
        x = screen.getch()  # Gets user input
        if x == curses.KEY_DOWN:
            pos += 1
            pos = min(pos, iy - (screenH-4))
        elif x == curses.KEY_UP:
            pos -= 1
            pos = max(pos,0)
    return 0


def processmenu(h, n, screen, menu, parent=None):
    "This function calls showmenu and then acts on the selected item"
    optioncount = len(menu['options'])
    exitmenu = False
    while not exitmenu:  # Loop until the user exits the menu
        getin = runmenu(h, n, screen, menu, parent)
        try:
            whattodo = menu['options'][getin]['type']
        except:
            whattodo = None
        # the last option is always needed to exit the menu
        if getin == optioncount:
            exitmenu = True
        elif whattodo == COMMAND:
            curses.def_prog_mode()    # save current curses environment
            os.system('reset')
            screen.clear()  # clears previous screen
            os.system(menu['options'][getin]['command'])  # run the command
            # clears previous screen on key press and updates display based on pos
            screen.clear()
            curses.reset_prog_mode()   # reset to 'current' curses environment
            curses.curs_set(1)         # reset doesn't do this right
            curses.curs_set(0)
        elif whattodo == PROMPT:
            curses.def_prog_mode()    # save current curses environment
            # this is not the good place, as it is specific to the usage
            screen.clear()  # clears previous screen
            dump_info(h, n, screen, menu['options'][getin], menu)
            # clears previous screen on key press and updates display based on pos
            screen.clear()
            curses.reset_prog_mode()   # reset to 'current' curses environment
            curses.curs_set(1)         # reset doesn't do this right
            curses.curs_set(0)
        elif whattodo == MENU:
            # clears previous screen on key press and updates display based on pos
            screen.clear()
            # display the submenu
            processmenu(h, n, screen, menu['options'][getin], menu)
            # clears previous screen on key press and updates display based on pos
            screen.clear()
        elif whattodo == INPUT:
            # All pressed key is used
            curses.def_prog_mode()    # save current curses environment
            # this is not the good place, as it is specific to the usage
            screen.clear()  # clears previous screen
            input_info(h, n, screen, menu['options'][getin], menu)
            # clears previous screen on key press and updates display based on pos
            screen.clear()
            curses.reset_prog_mode()   # reset to 'current' curses environment
            curses.curs_set(1)         # reset doesn't do this right
            curses.curs_set(0)
        elif whattodo == EXITMENU:
            exitmenu = True

dico_menu = { 'title': 0, 'subtitle': 1, 'DESCRIPTION': 2, 'default': 3}
def menu_cmp(key_x,key_y):
    "Function compare to sort the keys in order to compose the menu"
    global dico_menu
    kx = dico_menu.get(key_x,key_x)
    ky = dico_menu.get(key_y,key_y)
    return cmp(kx,ky)

def fitHelperResid(p, fit, prev):
  res = fit.proj - fit.gauss_eval(p, prev)
  print (res ** 2).sum()
  return res
  
class GaussianFit:
  I_FREAL = 0
  I_FIMAG = 1
  I_PHASE = 3
  I_DAMP = 2
  
  def __init__(self, id, l, N, x, proj, cutoff = None, init = None):
    import numpy
    self.id = id
    self.N = N
    self.l = l
    self.cutoff = cutoff
    self.init = init

    # Restrict fit to cutoff
    imax = x.size
    if cutoff is not None:
      rmax = cutoff * numpy.sqrt(3)
      for (i, v) in enumerate(x):
        if v > rmax:
          imax = i
          break
    self.x = x[:imax]
    self.proj = proj[:imax]

  def gauss_eval(self, p, prev):
    import numpy
    if prev is not None:
      v0 = numpy.hstack((prev.reshape(-1), p)).reshape((-1, 4))
    else:
      v0 = p.reshape((-1, 4))
    F = v0[:, GaussianFit.I_FREAL] + 1j * v0[:, GaussianFit.I_FIMAG]
    D = numpy.abs(v0[:, GaussianFit.I_DAMP])
    D[D < 0.01] = 0.01
    C = -D + 1j * v0[:, GaussianFit.I_PHASE]
    Fc = v0[:, GaussianFit.I_FREAL] - 1j * v0[:, GaussianFit.I_FIMAG]
    Cc = -D - 1j * v0[:, GaussianFit.I_PHASE]
    ret = self.x ** self.l
    for (i, xv) in enumerate(self.x):
      a = (F * numpy.exp(C * (xv ** 2)) + Fc * numpy.exp(Cc * (xv ** 2))).sum()
      #ret[i] = (xv ** n) * numpy.real(a)
      ret[i] *= numpy.real(a)
    return ret

  def resid_eval(self, p, prev = None):
    import numpy
    return numpy.trapz((self.proj - self.gauss_eval(p, prev)) ** 2, self.x) / self.x.max()

  def fit(self):
    import numpy
    from scipy.optimize import leastsq
    ## # Calculate weights to have a linear weight on points.
    ## weights = numpy.linspace(x[0], x[imax - 1], imax)
    ## weights[0] = weights[1]
    ## weights = x[:imax] / weights
    ## weights = weights / weights.sum() * imax

    # Input guess
    if self.init is not None:
      prev = numpy.loadtxt(self.init).reshape(-1)
    else:
      # Gaussian per gaussian
      avg = numpy.average(self.proj)
      prev = None
      for I in range(self.N):
        p0 = numpy.zeros(4, dtype = numpy.float)
        if I == 0:
          p0[GaussianFit.I_FREAL] = avg
          p0[GaussianFit.I_DAMP] = self.cutoff
          p0[GaussianFit.I_PHASE] = 1.1 ** (I + 1)
        else:
          p0[GaussianFit.I_FREAL] = 0.01
          p0[GaussianFit.I_DAMP] = self.cutoff
          p0[GaussianFit.I_PHASE] = 1.1 ** (I + 1)

        (p, info) = leastsq(fitHelperResid, p0.reshape(-1), args = (self, prev))
        if prev is not None:
          prev = numpy.hstack((prev.reshape(-1), p)).reshape((-1, 4))
        else:
          prev = p
        print prev
    # Try a full free optimization additional
    info = 5
    p = prev.reshape(-1)
    nTrial = 0
    while info > 4 and nTrial < 2:
      (p, info) = leastsq(fitHelperResid, p, args = (self, None))
      nTrial += 1
    # Constraints on exponents.
    p = p.reshape((-1, 4))
    p[:, GaussianFit.I_DAMP] = numpy.abs(p[:, GaussianFit.I_DAMP])
    p[:, GaussianFit.I_DAMP] = numpy.where(p[:, GaussianFit.I_DAMP] < 0.01, 0.01, p[:, GaussianFit.I_DAMP])

    return p

def jobFit(gauss):
  return gauss.fit()

def fitPAW(file, N):
  import numpy
  import xml.etree.ElementTree as ET
  from multiprocessing import Pool

  psp = ET.parse(file).getroot()

  cutoff = float(psp.find('paw_radius').get('rc'))

  grids = {}
  for grid in psp.findall('radial_grid'):
    grids[grid.get('id')] = numpy.fromstring(grid.find('values').text.replace('\n', ''), sep = ' ')

  #Only version > 2.7
  #projs = {state.get('id'):{'n': int(state.get('n', '1')),
  #                          'l': int(state.get('l'))} for state in psp.find('valence_states')}
  projs = {}
  for state in psp.find('valence_states'):
      projs[state.get('id')] = {'n': int(state.get('n', '1')), 'l': int(state.get('l'))}

  jobs = [GaussianFit(proj.get('state'), projs[proj.get('state')]['l'], N, grids[proj.get('grid')], numpy.fromstring(proj.text.replace('\n',''), sep = ' ', dtype = numpy.float64), cutoff) for proj in psp.findall('projector_function')]
  fits = Pool().map(jobFit, jobs)
  
  # Save projector and fit to disk.
  o = open("projs.yaml", "w")
  for (g, p) in zip(jobs, fits):
    o.write("%s:\n" % g.id)
    o.write("  function:\n")
    for vals in zip(g.x, g.proj):
      o.write("  - [%15.9g, %15.9g]\n" % vals)
    o.write("  fit:\n")
    o.write("    residual: %15.9g\n" % g.resid_eval(p))
    o.write("    gaussians:\n")
    for vals in p:
      o.write("    - {\"factor\": [%15.9g, %15.9g], \"exponent\": [%15.9g, %15.9g]}\n" % tuple(vals))
  o.close()

def gauss2plot(file):
  import numpy, yaml
  projs = yaml.load(open(file, "r").read(), Loader = yaml.CLoader)
  og = open("projG", "w")
  for (k, v) in projs.items():
    o = open("proj%s" % k, "w")
    for vals in v["function"]:
      o.write("%g %g\n" % tuple(vals))
    o.close()

    proj = numpy.zeros((len(v["fit"]["gaussians"]), 4))
    for (i, g) in enumerate(v["fit"]["gaussians"]):
      proj[i, :] = g["factor"] + g["exponent"]
    og.write("g_%s(x) = \\\n" % k)
    for (fr, fi, d, p) in proj:
      og.write("{%g, %g}*exp({-%g, %g} * (x ** 2)) + {%g, %g}*exp({-%g, %g} * (x ** 2)) + \\\n" % (fr, fi, d, p, fr, -fi, d, -p))
    og.write("0\n")

def gauss2xml(file):
  import numpy, yaml
  projs = yaml.load(open(file, "r").read(), Loader = yaml.CLoader)
  for (k, v) in projs.items():
    proj = numpy.zeros((len(v["fit"]["gaussians"]), 4))
    for (i, g) in enumerate(v["fit"]["gaussians"]):
      proj[i, :] = g["factor"] + g["exponent"]
    print "<projector_fit state=\"%s\" residual=\"%g\">" % (k, v["fit"]["residual"])
    for gauss in proj:
      print "  <gaussian factor=\"{%g, %g}\" exponent=\"{%g, %g}\" />" % tuple(gauss)
    print "</projector_fit>"


# Start the main script
if __name__ == "__main__":
    parser = parse()
    (options, args) = parser.parse_args()
    # Treat some general options
    options.logging = ""
    if (options.log_to_disk):
      options.logging=" l"

    # Try to find memguess executable.
    memguess = None
    if os.path.isfile(os.path.join(os.path.dirname(sys.argv[0]), "memguess")):
        memguess = os.path.join(os.path.dirname(sys.argv[0]), "memguess")
    elif os.path.isfile("./memguess"):
        memguess = "./memguess"
    elif os.path.isfile(os.path.join(abs_top_builddir, "src", "memguess")):
        memguess = os.path.join(abs_top_builddir, "src", "memguess")
    elif os.path.isfile(os.path.join(bindir, "bin", "memguess")):
        memguess = os.path.join(bindir, "bin", "memguess")


    # Try to find utilities executable.
    utilities = None
    if os.path.isfile(os.path.join(os.path.dirname(sys.argv[0]), "utilities")):
        utilities = os.path.join(os.path.dirname(sys.argv[0]), "utilities")
    elif os.path.isfile("./utilities"):
        utilities = "./utilities"
    elif os.path.isfile(os.path.join(abs_top_builddir, "src", "utilities")):
        utilities = os.path.join(abs_top_builddir, "src", "utilities")
    elif os.path.isfile(os.path.join(bindir, "bin", "utilities")):
        utilities = os.path.join(bindir, "bin", "utilities")


    command = None
    # Run memguess
    if options.action == "memory-estimation":
        command = "%s %d %s dd%s" % (memguess, options.n_proc, options.name, options.logging)
    elif options.action == "rotate":
        command = "%s 1 %s dd%s o" % (memguess, options.name, options.logging)
    if options.action == "convert-field":
        if len(args) < 2:
            parser.print_help()
            raise ValueError(
                "Action '%s' requires two mandatory arguments" % actions[2])
        command = "%s 1 dd%s convert %s %s" % (memguess, options.logging, args[0], args[1])
    if options.action == "export-wf":
        if len(args) < 1:
            parser.print_help()
            raise ValueError(
                "Action '%s' requires one mandatory argument" % actions[3])
        command = "%s 1 %s dd%s exportwf %s %d %d %d %d" % (memguess, options.name,
                                                            options.logging, args[
                                                              0], options.i_band, options.i_spin, options.i_kpt, options.i_complex)
    if options.action == "export-proj":
        if len(args) < 1:
            parser.print_help()
            raise ValueError(
                "Action '%s' requires one mandatory argument" % actions[22])
        command = "%s 1 %s dd%s exportproj %s" % (memguess, options.name,
                                                            options.logging, args[
                                                              0])
    if options.action == "export-grid":
        command = "%s 1 %s dd%s y" % (memguess, options.name, options.logging)
    if options.action == "atomic-wf":
        command = "%s 1 %s dd%s atwf %d" % (
            memguess, options.name, options.logging, options.n_gaussians)
    if options.action == "GPU-test":
        command = "%s 1 %s dd%s GPUtest %d %d" % (
            memguess, options.name, options.logging, options.n_repeats, options.n_orbs)
    if options.action == "convert-positions":
        if len(args) < 2:
            parser.print_help()
            raise ValueError(
                "Action '%s' requires two mandatory arguments" % actions[7])
        command = "%s 1 dd%s convert-positions %s %s" % (
            memguess, options.logging, args[0], args[1])

    # Manual
    if options.action == "manual":
        # to parse and document the input variables
        import yaml
        import pprint
        try:
            fulldoc = [a for a in yaml.load_all(
                open(inputvarfile, "r").read(), Loader=yaml.CLoader)]
        except Exception, e:
            print str(e)
            print 'Error in opening input variable definition file, cannot proceed'
            sys.exit(1)
        params = fulldoc[0]
        files = params.keys()
        print 'Possible fields', files
        pprint.pprint(files)
        allkeys = []
        for f in files:
            allkeys += params[f].keys()
        print ' Possible keys', allkeys, len(allkeys)
        pprint.pprint(allkeys)
        # try to see if a key matches a expression
        if options.find_key is not None:
            searchfor = options.find_key
            matching_keys = closest_keys(allkeys, searchfor)
            print 'matching', searchfor, 'in:', matching_keys
            print 'keys wich match the most with', searchfor
            foundkeys = []
            doc = []
            for (i, ratio) in matching_keys:
                if ratio > 0.5 and i not in foundkeys:
                    for f in find_files(params, i):
                        dc = {}
                        dc['Key found'] = i
                        dc['Similarity'] = ratio
                        dc['Field'] = f
                        dc['Description'] = params[f][i]
                        doc.append(dc)
                        foundkeys.append(i)
            sys.stdout.write(
                yaml.dump(doc, default_flow_style=False, explicit_start=True))
        infiles = fulldoc[1]
        profs = infiles.keys()
        print 'Possible profiles:'
        for p in profs:
            print '-', p, infiles[p]["COMMENT"]
        print 'profile searched', options.profile
        if options.profile in profs:
            sys.stdout.write(yaml.dump(
                infiles[options.profile], default_flow_style=False, explicit_start=True))
    if options.action == "wizard":
    #Wizard
        # experimental mode to pretty print information with ncurses
        # define the information for printing with ncurses
        menu_yaml_base = \
            """
type: menu
title: Welcome to BigDFT tool wizard!
subtitle: Please select an action to do...
options:
- type: menu
  title: Inspect the possible keys of input file
  subtitle: Select the key field
- type: menu
  title: Inspect the possible input file setups ('import key')
  subtitle: Select the input setup
- type: input
  title: Search for a key name
  subtitle: Type the key you would like to search for
"""
        import yaml
        try:
            fulldoc = [a for a in yaml.load_all(
                open(inputvarfile, "r").read(), Loader=yaml.CLoader)]
        except Exception, e:
            print str(e)
            print 'Error in opening input variable definition file, cannot proceed'
            sys.exit(1)
        # then fill the menu of the information
        menu = yaml.load(menu_yaml_base)
        # processmenu(menu_data)
        params = fulldoc[0]
        files = params.keys()
        files.sort()
        print 'Possible fields', files
        allkeys = []
        for f in files:
            allkeys += params[f].keys()
        print ' Possible keys', allkeys, len(allkeys)
        infiles = fulldoc[1]
        profs = infiles.keys()
        profs.sort()
        print 'Possible profiles:'
        for p in profs:
            print '-', p, infiles[p]["COMMENT"]
        print 'profile searched', options.profile
        if options.profile in profs:
            sys.stdout.write(yaml.dump(
                infiles[options.profile], default_flow_style=False, explicit_start=True))
        # complete the menu with the keys
        dockey = []
        for f in files:
            dico = { 'type': MENU, 'title': f, 'subtitle': ''}
            dico['options'] = []
            # keep all keys
            keysf = params[f].keys()
            keysf.sort()
            for k in keysf:
                if k == 'DESCRIPTION':
                    # Give the description of the given menu
                    dico['DESCRIPTION'] = params[f][k]
                    #dico['title'] += ' (%s)' % dico['DESCRIPTION']
                    continue
                dd = {'type': PROMPT, 
                      'title': k + '     (' + str(params[f][k]['COMMENT']) + ')',
                      'subtitle': "Extended description for the input keyword '%s'" % str(k),
                      'DESCRIPTION': 'No extended description for this key specified yet.\n',
                      'COMMENT': '' }
                dd.update(params[f][k])
                dico['options'].append(dd)
            dockey.append(dico)
        menu['options'][0]['options'] = dockey
        # now the same for the input file setups
        dockey = []
        for f in profs:
            inputfile = infiles[f]
            helpstr = ''
            if infiles[f].has_key('DESCRIPTION'):
                helpstr += inputfile.pop('DESCRIPTION') 
            if infiles[f].has_key('COMMENT'):
                comment = inputfile.pop('COMMENT')
            else:
                comment = ''
            helpstr += "List of specific keys associated with the import key '%s'.\n\n" % str(f)
            helpstr += yaml.dump(inputfile, default_flow_style=False)
            dico = {'type': PROMPT, 
                    'title': f + '     (' + str(comment) + ')',
                    'subtitle': "Extended description for the import key '%s'" % str(f),
                    'DESCRIPTION': helpstr}
            dockey.append(dico)
        menu['options'][1]['options'] = dockey
        sys.stdout.write(
            yaml.dump(menu, default_flow_style=False, explicit_start=True))
        # ertet
        # Initializes a new window for capturing key presses
        screen = curses.initscr()
        # Disables automatic echoing of key presses (prevents program from
        # input each key twice)
        curses.noecho()
        # Disables line buffering (runs each key as it is pressed rather than
        # waiting for the return key to pressed)
        curses.cbreak()
        # Lets you use colors when highlighting selected menu option
        curses.start_color()
        screen.keypad(1)  # Capture input from keypad
        screen.notimeout(1)  # Disables timeout for esc key
        # Change this to use different colors when highlighting
        # Sets up color pair #1, it does black text with white background
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        # h is the coloring for a highlighted menu option
        h = curses.color_pair(1)
        # n is the coloring for a non highlighted menu option
        n = curses.A_NORMAL
        #Check if the height of window is enough
        H,W = screen.getmaxyx()
        if H > 6:
            processmenu(h, n, screen, menu)
        # VITAL! This closes out the menu system and returns you to the bash
        # prompt.
        curses.endwin()
        if H <= 6:
            sys.stdout.write("ERROR: The window is too thin!\n")
        os.system('clear')

    #Conversion coordinates        
    if options.action == "transform-coordinates":
        print 'calling memguess for coordinate conversion'
        infile_names = options.infile.split(".")
        outfile_names = options.outfile.split(".")
        infile_extension = infile_names[len(infile_names)-1]
        outfile_extension = outfile_names[len(outfile_names)-1]
        in_is_car = infile_extension=='xyz' or infile_extension=='ascii' or infile_extension=='yaml'
        in_is_int = infile_extension=='int'
        out_is_car = outfile_extension=='xyz' or outfile_extension=='ascii' or outfile_extension=='yaml'
        out_is_int = outfile_extension=='int'
        if in_is_car and out_is_car:
            direction = 'carcar'
        elif in_is_car and out_is_int:
            direction = 'carint'
        elif in_is_int and out_is_car:
            direction = 'intcar'
        else:
            direction = 'not supported'
        command = "%s 1 %s dd transform-coordinates %s  %s %s" % (memguess, options.name, direction, options.infile, options.outfile)
        print command
    if options.action == "pdos":
        print 'calling memguess for PDOS'
        #infile_names = options.infile.split(".")
        #infile_extension = infile_names[len(infile_names)-1]
        #command = "%s 1 %s dd pdos %s %s %s %d %d %d %e %s %s" % (memguess, options.name, options.coeff_file, options.hamiltonian_file, options.overlap_file, options.nbasis, options.norb, options.nat, options.interval, options.pdos_file, options.posinp_file)
        #command = "%s 1 %s dd pdos %s %s %s %s" % (memguess, options.name, options.coeff_file, options.hamiltonian_file, options.overlap_file, options.pdos_file)
        command = "%s %s pdos %s %s %s %s" % (options.mpirun, utilities, options.coeff_file, options.hamiltonian_file, options.overlap_file, options.pdos_file)
        print command
    if options.action == "kernel-analysis":
        print 'calling memguess for kernel analysis'
        command = "%s 1 %s dd kernel-analysis %s %s %d %d %d" % (memguess, options.name, options.coeff_file, options.kernel_file, options.nbasis, options.norb, options.nat)
        print command
    if options.action == "extract-submatrix":
        print 'calling memguess for submatrix extraction'
        command = "%s 1 %s dd extract-submatrix %s %d %d %d" % (memguess, options.name, options.matrix_file, options.nbasis, options.nat, options.nsubmatrices)
        print command
    if options.action == "solve-eigensystem":
        print 'calling memguess to solve the eigensystem'
        #command = "%s 1 %s dd solve-eigensystem %s %s %d %d %s" % (memguess, options.name, options.hamiltonian_file, options.overlap_file, options.nbasis, options.nat, options.coeff_file)
        command = "%s %s solve-eigensystem %s %s %s" % (options.mpirun, utilities, options.hamiltonian_file, options.overlap_file, options.coeff_file)
    if options.action == "analyse-coeffs":
        print 'calling memguess to analyse the coeffs'
        command = "%s 1 %s dd analyze-coeffs %s %d %d %d %d" % (memguess, options.name, options.coeff_file, options.nbasis, options.norb, options.nat, options.ncategories)
        print command
    if options.action == "peel-matrix":
        print 'calling memguess to peel a matrix'
        command = "%s 1 %s dd peel-matrix %s %d %d %e" % (memguess, options.name, options.matrix_file, options.nbasis, options.nat, options.cutoff)
        print command
    if options.action == "multiply-matrices":
        print 'calling memguess to multiply two matrices'
        command = "%s 1 %s dd multiply-matrices %s %s %s %d %d" % (memguess, options.name, options.amatrix_file, options.bmatrix_file, options.cmatrix_file, options.nbasis, options.nat)
    if options.action == "matrixpower":
        print 'calling memguess to calculate matrix**power'
        command = "%s 1 %s dd matrixpower %s %s %d %d %e" % (memguess, options.name, options.inmatrix_file, options.outmatrix_file, options.nbasis, options.nat, options.power)
        print command
    if options.action == "plot-wavefunction":
        print 'not implemented yet'
    if options.action == "suggest-cutoff":
        print 'calling memguess to suggest cutoff radii'
        command = "%s 1 %s dd suggest-cutoff %s" % (memguess, options.name, options.posinp_file)
        print command
    if options.action == "charge-analysis":
        #print 'calling utilities to perform a Loewdin charge analysis'
        command = "%s %s charge-analysis %s %s %s %s" % (options.mpirun, utilities, options.method, options.overlap_file, options.kernel_file, options.hamiltonian_file)
        print command
    if options.action == 'dos'
        print 'calling memguess for DOS'
        command = "%s 1 %s dd dos %s %s %s %s %s" % (memguess, options.name, options.coeff_file, options.hamiltonian_file, options.overlap_file, options.sigma, options.npts)
        #print command
    if options.action == "fit-proj":
        if len(args) < 1:
            parser.print_help()
            raise ValueError(
                "Action '%s' requires one mandatory argument" % actions[23])
        if args[0].endswith(".yaml"):
          gauss2xml(args[0])
          gauss2plot(args[0])
        else:
          fitPAW(args[0], options.n_funcs)
    if command is not None:
        os.system(command)
